load(to_poly_solve)$

/*∘(f, g) := compose_functions([f, g]);*/
∘(f, g) := block([], v: new_variable('general), 
                    buildq([expr: expand(f(g(rat(v)))), v: v], lambda([v], expr)))$
infix("∘")$

deal(i) := -i - 1;
cut[n](i) := i - n;
increment[n](i) := i * n;

parse(l) := block([], if sequal(split(l)[1], "cut") then return(cut[parse_string(split(l)[2])]),
            if sequal(split(l)[1], "deal") then (
              if sequal(split(l)[3], "increment") then return(increment[parse_string(split(l)[4])]),
              return(deal)
            ))$

/*(L: [], while (c : readline(stdin)) # false do push(parse(c), L), f: compose_functions(L))$*/
(f: identity, while (l : readline(stdin)) # false do f: parse(l) ∘ f)$

"⁻¹"(g) := block([], v: new_variable('general), 
                    buildq([expr: ev(x, solve(v = g(x), x)), v: v], lambda([v], expr)))$
postfix("⁻¹")$

modulus: 10007$ /* number of cards */
f(rat(x));
f⁻¹(rat(x));
f(rat(2019));
f⁻¹(rat(3589));

log2(x) := log(x) / log(2)$
"°"(f, n) := °[f, n]$
infix("°")$
"°"[f, n] := block([],
            if (n = 1) then return(f),
            if (n = 2) then return(f ∘ f),
            if (mod(float(log2(n)), 1) = 0.0) then return((f°(2^(floor(float(log2(n))) - 1)))°2),
            return((f°(2^floor(float(log2(n))))) ∘ (f°(n-(2^floor(float(log2(n))))))))$

modulus: 119315717514047$ /* number of cards */

supershuffle: f⁻¹°101741582076661;
supershuffle(x);
supershuffle(rat(2020));
